# Mastermind Game

[![Netlify Status](https://api.netlify.com/api/v1/badges/45006e28-5bc0-4d75-aa62-3025556963c0/deploy-status)](https://app.netlify.com/sites/mastermind-lily/deploys)

The game is [deployed](https://mastermind-lily.netlify.com/) on Netlify, but I recommend running locally or checking out the version on [CodeSandbox](https://codesandbox.io/s/github/lilyhoratio/mastermind) due to small Netlify issues in loading animations.

## Table of Contents

- [Overview](#overview)
- [Steps to run locally](#steps-to-run-locally)
- [Features](#features)
- [Application Structure](#application-structure)
- [Code Refactoring Highlights](#Code-refactoring-highlights)
- [Unit Tests](#unit-tests)
- [Future Improvements](#future-improvements)
- [Tech stack](#tech-stack)

## Overview

Mastermind is a code-breaking game where the user attempts to guess the digits of a secret PIN. It is a take on the [Mastermind board game](<https://en.wikipedia.org/wiki/Mastermind_(board_game)>).

The player must guess a 4 digit code that has been randomly generated by the computer. At the end of each try, the computer provides feedback on whether the player guessed a number correctly and/or a number and its location correctly. The computer's feedback does not reveal which number the player guessed correctly.

To win, the player must guess the right combinations within 10 attempts.

![Game](images/mastermind.png)

## Steps to run locally

1. `git clone https://github.com/lilyhoratio/mastermind.git`
2. `cd mastermind-lily`
3. `yarn` to install dependencies
4. `yarn start` to launch React app
5. `yarn test` to run tests

## Features

MVP:

- [x] Ability to guess the combinations of 4 numbers
- [x] Ability to view the history of guesses and their feedback
- [x] The number of guesses remaining is displayed

Extra features:

- [x] Ability to toggle viewing the code combination for easier user testing
- [x] Conditional rendering of won game vs. lost game pop-ups
- [x] Ability to restart game by generating a new code combination - in pop-up when user wins or loses game, and the "Generate new code" component
- [x] Computer gives feedback after each guess with the count of exact (correct digit/location) vs. fuzzy matches (correct digit, not location)
- [x] User is prevented from accessing the input form after guessing the correct combination or when they reach 10 tries (form disappears)

![Modal-win](modal-win.gif)

- [x] Pacman ghost animation alert with conditional text for invalid inputs when the user:

  - types in non-integers
  - types an invalid digit (not between 0-7)
  - enters nothing
  - enters guess with more than 4 digits

- [x] Clippy (ðŸ“Ž) animation when user wants to change difficulty, which prompts the user to change the number of max tries allowed. Changing the max tries resets state for number of guesses remaining.

![Error-handling](error-handling.gif)

## Application Structure

![Application-Structure](images/application_structure.png)

## Code Refactoring Highlights

I originally coded a simpler form of this as a CLI game using Node.js. After I got the basic game working, I decided to make it into a web app using React. Managing the state among different components proved to be more challenging than I expected, especially as I added more interactivity and detail to the computer feedback, while also breaking the game into smaller components and adding helper functions for DRY code. Here are some highlights of my thought process!

### Bug fix in algorithm to count exact vs. fuzzy matches

My first implementation had a bug in counting the exact match vs. fuzzy match of digits in the guess. Because the user could enter a code with duplicate digits, the count of fuzzy matches was sometimes inflated. For example, if the number was 5124, and the user guessed, 5555, the computer incorrected indicated 1 exact match and 3 fuzzy matches (should have been 0 fuzzy matches).

```javascript
const getComputerFeedback = guess => {
  let guessAndFeedback = { guess: guess };
  let fuzzyMatch = 0;
  let exactMatch = 0;

  for (let i = 0; i < guess.length; i++) {
    if (guess[i] === integerCombo[i]) {
      exactMatch++;
    }
    if (integerComboCopyArr.includes(guess[i])) {
      fuzzyMatch++;
    }
  }

  fuzzyMatch = fuzzyMatch - exactMatch;

  if (exactMatch === 4) {
    guessAndFeedback["feedback"] = "you win";
    setIsGameOver(true);
    setIsGameWon(true);
  } else if (fuzzyMatch === 0 && exactMatch === 0) {
    guessAndFeedback["feedback"] = "all incorrect";
  } else {
    guessAndFeedback[
      "feedback"
    ] = `exact match: ${exactMatch}, fuzzy match: ${fuzzyMatch}`;
  }

  return guessAndFeedback;
};
```

This is my fix for to calculate the correct counts of exact vs. fuzzy matches to account for duplicate digits in the guess and code. I also broke out the main business logic to get the correct counts in a helper function separate from the React visual component:

```javascript
// ======= Helper function to count the number of fuzzy and exact matches
const countFuzzyAndExactMatches = (guess, code) => {
  let fuzzyMatch = 0;
  let exactMatch = 0;

  // Check for exact matches by comparing each index's element of guess to the analogous one in code
  // For matches, mark them as seen by updating element to null so that the next for loop
  // does not inflate fuzzy matches when guess contains duplicate digits that are in code
  // For example: if code = 4322 and guess = 2222, should expect exactMatch = 2 && fuzzyMatch = 0 (rather than fuzzyMatch = 2)
  for (let i = 0; i < code.length; i++) {
    if (guess[i] === code[i]) {
      exactMatch++;
      guess[i] = null;
      code[i] = null;
    }
  }

  // Check for fuzzy matches by checking if the guess element is included in the code and is not an exact match
  // For fuzzy matches, mark already seen digits from the code as seen by updating element to null so that they are not double counted
  // For example: if code = 0223 and guess = 2022, should expect exactMatch = 1 && fuzzyMatch = 2 (rather than fuzzyMatch = 3)
  for (let i = 0; i < code.length; i++) {
    if (code.includes(guess[i]) && guess[i] !== code[i]) {
      fuzzyMatch++;
      code[code.indexOf(guess[i])] = null;
    }
  }

  return { fuzzyMatch, exactMatch };
};

// ======= Algorithm to determine computer's feedback based on user's input
const getComputerFeedback = guess => {
  let guessAndFeedback = { guess: guess };
  let guessCopy = convertStringToIntArray(guess);
  let codeCopy = [...code];

  const { fuzzyMatch, exactMatch } = countFuzzyAndExactMatches(
    guessCopy,
    codeCopy
  );

  if (exactMatch === 4) {
    guessAndFeedback["feedback"] = "you win";
    setIsGameOver(true);
    setIsGameWon(true);
  } else if (fuzzyMatch === 0 && exactMatch === 0) {
    guessAndFeedback["feedback"] = "all incorrect";
  } else {
    guessAndFeedback[
      "feedback"
    ] = `exact match: ${exactMatch}, fuzzy match: ${fuzzyMatch}`;
  }

  return guessAndFeedback;
};
```

Setting a key and value for each conditional statement seemed repetitive, so I further refactored the function into the following:

```js
const getComputerFeedback = guess => {
  let feedback = "";

  // ===== hidden code ===== //

  if (exactMatch === 4) {
    feedback = "you win";
    setIsGameOver(true);
    setIsGameWon(true);
  } else if (fuzzyMatch === 0 && exactMatch === 0) {
    feedback = "all incorrect";
  } else {
    feedback = `exact match === ${exactMatch} && fuzzy match === ${fuzzyMatch}`;
  }

  return { guess, feedback };
};
```

### API call - refactoring into a custom hook

Originally, in App.js, this was my API call:

```js
const [code, setCode] = useState([]);

useEffect(() => {
  api
    .getRandomIntegers()
    .then(res => {
      let rawIntegers = res.data;
      let cleanedIntegers = convertStringToIntArray(rawIntegers, "\n");
      cleanedIntegers.pop(); // remove last element due to extra \n separator
      setCode(cleanedIntegers);
    })
    .catch(err => console.log(err));
}, []);
```

Because I wanted the ability to reset the random integer in other components based on user interactions in other components, I ended up abstracting away the logic of the API call through a custom hook. Thanks to these two articles for guides on how to do so: https://blog.siliconjungles.io/how-to-use-react-hooks-to-abstract-api-calls & https://blog.bitsrc.io/simple-code-reuse-with-react-hooks-432f390696bf.

```js
// In hooks.js

export function useRandomInteger() {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  const changeData = () => {
    api
      .getRandomIntegers()
      .then(res => {
        let rawIntegers = res.data;
        let cleanedIntegers = convertStringToIntArray(rawIntegers, "\n");
        cleanedIntegers.pop(); // remove last element due to extra \n separator
        setIsLoading(true);
        setData(cleanedIntegers);
      })
      .catch(err => {
        console.log(err);
        setError(err);
      });
  };

  return [data, changeData, isLoading, error];
}
```

App.js could now be simplified to to the following:

```js
// In App.js:
const [code, changeCode, isLoading, error] = useRandomInteger();

useEffect(() => {
  changeCode();
}, []);
```

And the `changeCode` function passed down to <GameStats /> component and used in an onClick method:

```js
// In <GameStats /> component:

<div className="button new-game-button" onClick={changeCode}>
  â†» Generate new code â†»
</div>
```

I also refactored the base API call from a hardcoded call to variable based on the API call's parameters:

```js
// In services/api.js

// From:
export function getRandomIntegers(integerParams) {
  return axios.get(`${baseUrl}/integers/?num=4&min=0&max=7&col=1&base=10&format=plain&rnd=new`)
  );
}

// To:
export function getRandomIntegers(integerParams) {
  let { num, min, max, col, base, format, rnd } = integerParams;
  return axios.get(
    `${baseUrl}/integers/?num=${num}&min=${min}&max=${max}&col=${col}&base=${base}&format=${format}&rnd=${rnd}`
  );
}

```

### Helper methods

I also noticed the logic to clean the user input was similar to the logic to clean the API response, so created a helper function called
`convertStringToIntArray` to convert both the Random Integer API response and user input from raw strings into an array of integers.

```js
// In src/services/helpers.js
const convertStringToIntArray = (stringInt, separator = "") => {
  return stringInt.split(separator).map(stringInt => parseInt(stringInt, 10));
};

// Above function is used in hooks/useAPI.js:
api.getRandomIntegers().then(res => {
  let rawIntegers = res.data;
  let cleanedIntegers = convertStringToIntArray(rawIntegers, "\n");
  // etc
});

// Also used in App.js to convert the user's form input:
let guessCopy = convertStringToIntArray(guess);
```

### Pacman Ghost animation based on invalid user inputs

The nostalgia of my terminal theme game made me think of Pacman. In order to animate my Pacman ghost, I set `appear` as a boolean state which defaulted to `false`. This variable would be set to `true` if the user input went into several conditionals, which are reflected in the `handleChange` and `handleSubmit` functions.

Making the ghost animate was trickier than I expected, and I learned about the React synthetic event called onAnimationEnd. In order to reset `appear` back to `false` using the `setAppear` hook, I invoked the `setAppear` hook onAnimationEnd of the CSS animation. This allowed me to conditionally render a className `ghost-container` vs. `ghost-container-hidden` based on the `appear` state.

```js
// <GuessInput /> component

import React, { useState } from "react";
import Ghost from "../images/ghost.png";

function PlayerGuessInput({ addGuess, isGameOver }) {
  const [guess, setGuess] = useState("");
  const [appear, setAppear] = useState(false);
  const [ghostText, setGhostText] = useState("");

  const handleChange = e => {
    if (e.target.value.match(/\D/)) {
      setGhostText("only numbers allowed!!!");
      setAppear(true);
    } else if (e.target.value.match(/[8-9]/)) {
      setGhostText(`${e.target.value} is not between 0-7!!!`);
      setAppear(true);
    } else {
      setGuess(e.target.value);
    }
  };

  const handleSubmit = e => {
    e.preventDefault();

    if (guess.length > 4) {
      setGhostText("too many digits!!!");
      setAppear(true);
    } else if (guess.length === 0) {
      setGhostText("enter something!!!");
      setAppear(true);
    } else {
      addGuess(guess);
      setGuess("");
    }
  };

  return (
    !isGameOver && (
      <>
        <form onSubmit={handleSubmit}>
          <label>
            Enter 4 digits (0-7):
            <input
              type="text"
              name="guess"
              placeholder=""
              value={guess}
              onChange={handleChange}
              className="guess-input"
            />
          </label>
        </form>
        <div
          className={`ghost-container${appear ? "" : "-hidden"}`}
          onAnimationEnd={() => setAppear(false)}
        >
          <img id="ghost" src={Ghost} alt="ghost" />
          <span id="ghost-rawr">{ghostText}</span>
        </div>
      </>
    )
  );
}

export default PlayerGuessInput;
```

The SASS for the animation-related classes was as follows:

```scss
.ghost-container {
  position: fixed;
  bottom: 10px;
  left: 10px;
  display: flex;
  flex-direction: row;
  animation: ghostappears 4s ease;

  #ghost {
    width: 100px;
    height: auto;
  }

  #ghost-rawr {
    color: red;
    font-weight: bold;
    z-index: 999;
  }
}

.ghost-container-hidden {
  opacity: 0%;
}

@keyframes ghostappears {
  0% {
    opacity: 10%;
    transform: translateY(100px);
  }
  20% {
    opacity: 100%;
    transform: translateY(0px);
  }
  50% {
    opacity: 100%;
    transform: translateY(20px);
  }
  100% {
    opacity: 10%;
    transform: translateY(100px);
  }
}
```

## Unit Tests

Testing the helper method:

```js
test("convertStringToArray converts a string with separators to an array of integers", () => {
  //   expect(convertStringToIntArray("1, 2, 3, 10", ",")).toEqual([1, 2, 3, 4]); // started with failing test

  expect(convertStringToIntArray("1, 2, 3, 4", ",")).toEqual([1, 2, 3, 4]);

  expect(convertStringToIntArray("1\n2\n3\n4", "\n")).toEqual([1, 2, 3, 4]);

  expect(convertStringToIntArray("1\t2\t3\t4", "\t")).toEqual([1, 2, 3, 4]);
});
```

Testing the business logic of counting the exact vs. fuzzy matches:

```js
import { countFuzzyAndExactMatches } from "./logic.js";

describe("countFuzzyAndExactMatches()", () => {
  test("if guess and code have no elements in common", () => {
    expect(countFuzzyAndExactMatches([1, 1, 2, 2], [3, 4, 5, 6])).toEqual({
      fuzzyMatch: 0,
      exactMatch: 0
    });
  });

  test("if guess is exactly the code", () => {
    expect(countFuzzyAndExactMatches([1, 2, 5, 5], [1, 2, 5, 5])).toEqual({
      fuzzyMatch: 0,
      exactMatch: 4
    });
  });

  test("if guess is all fuzzy matches", () => {
    expect(countFuzzyAndExactMatches([1, 2, 3, 4], [4, 3, 2, 1])).toEqual({
      fuzzyMatch: 4,
      exactMatch: 0
    });
  });

  test("if guess contains duplicate digits that occur in code, do not inflate fuzzy matches", () => {
    expect(countFuzzyAndExactMatches([4, 3, 2, 2], [2, 2, 2, 2])).toEqual({
      fuzzyMatch: 0,
      exactMatch: 2
    });
  });

  test("if guess contains duplicate digits that occur in code, do not inflate fuzzy matches", () => {
    expect(countFuzzyAndExactMatches([0, 2, 2, 3], [2, 0, 2, 2])).toEqual({
      fuzzyMatch: 2,
      exactMatch: 1
    });
  });
});
```

With more time, I would like to test the following, perhaps using the Cypress UI testing library:

- guesses left decrement for each valid input
- correct conditional text from ghost appears for invalid inputs
- generate new code API call resets all game's state
- test API to expect certain response

## Future Improvements

With more time, I would love to add the following:

- Mobile-responsive
- Create pop-up that displays the `error` if API is down.
- Break out the SASS files into different components, rather than all in App.scss
- Refactor more custom hooks for toggling boolean hooks (guide: https://daveceddia.com/custom-hooks/)
- Fix Bug: if user initially has 15 guesses total, guesses 11 times, and then changes their total guesses to 10, the app breaks
- Toggle for light/dark mode
- Loading state when generating a new API - create a helper function that resets all state in game on "generate new code" button. Right now, I am hacking this by simply reloading the window.

## Tech Stack

- [React](https://reactjs.org/) to appease Mark Zuckerberg (and for efficiency, responsiveness, and code componentization)
- [SASS](https://sass-lang.com/) for variables and nesting the CSS
- [Axios](https://github.com/axios/axios) for HTTP requests
- [Random.org API](https://www.random.org/clients/http/api) for random numbers
- [Clippy.js](https://github.com/SaraVieira/useClippy) for ðŸ“Ž
